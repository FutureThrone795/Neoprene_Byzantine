use std::cell::RefCell;

use crate::rational::Rational;

enum TransitiveConsts {
    Pi,
    Euler
}

enum ByzNode {
    Rational{
        rational: Rational
    },
    TransitiveConst{
        transitive_const: TransitiveConsts
    },
    Add{
        addends: Vec<RefCell<ByzNode>>
    },
    Mul{
        products: Vec<RefCell<ByzNode>>
    },
    Pow{
        base: Box<RefCell<ByzNode>>, 
        exp: Rational
    }
}

impl ByzNode {
    pub fn simplify_recursive(&mut self) {
        match self {
            ByzNode::Rational{rational} => {
                rational.simplify();
            },
            ByzNode::TransitiveConst { .. } => {
                // No changes
            }
            ByzNode::Add{addends} => {
                for addend in addends.iter() {
                    addend.borrow_mut().simplify_recursive();
                }



                if addends.len() == 1 {
                    *self = addends.pop().unwrap().into_inner();
                }
            }
            ByzNode::Mul{products} => {
                for product in products.iter() {
                    product.borrow_mut().simplify_recursive();
                }



                if products.len() == 1 {
                    *self = products.pop().unwrap().into_inner();
                }
            }
            ByzNode::Pow{base, exp} => {
                base.borrow_mut().simplify_recursive();
                exp.simplify();

                if exp.is_int_assume_simplified() {
                    match &*base.borrow() {
                        ByzNode::Rational{rational} => {
                            let mut a = rational.clone(); // A clone would theoretically be unnecessary here but I couldn't figure out how to fenagle it
                            a.powi(&exp.numer);

                            drop(&base);

                            *self = ByzNode::Rational { 
                                rational: a 
                            };
                        }
                        _ => {}
                    }
                }
            }
        }
    } 
}